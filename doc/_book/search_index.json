[["introduction.html", "Using the pdphmc package 1 Introduction 1.1 Getting pdphmc", " Using the pdphmc package Tore Selland Kleppe 2021-02-19 1 Introduction This bookdown aims to document the usage of the package pdphmc. The package implements a class of piecewise deterministc Markov processes (PDMP) where the deterministic dynamics are those of a Hamiltonian dynamic system. The actual PDMP algorithm is described in detail at https://arxiv.org/abs/2005.01285 and is not repeated in much detail here. Rather this bookdown describes how to use the software for analyzing your own models how to choose suitable tuning parameters influencing the behaviour of the sampling algorithm 1.1 Getting pdphmc So far pdphmc is only available on github. Before installing pdphmc, make sure that you have a working installation of rstan (see RStan getting started) and the you are running R version 4.0 or greater. The software is routinely tested on mac, linux and windows (using the compiler that ships with rtools). pdphmc is most easily installed using (requires the devtools package) #install.packages(&quot;devtools&quot;) devtools::install_github(&quot;https://github.com/torekleppe/pdphmc&quot;) "],["usage.html", "2 Usage 2.1 Building a model 2.2 Running a model 2.3 Handling output", " 2 Usage Postponing the definition of new models through model files to Chapter 3, the typical workflow when using pdphmc consists of the following three steps: Building the model. Fitting the model to a given data set. Using output of the fitting process. Throughout this chapter, we consider the very simple model \\(y_i \\sim N(\\mu,1),\\;i=1,\\dots,n\\) where \\(\\{y_i\\}_{i=1}^n\\) are observed, the single parameter \\(\\mu\\) has a flat prior, and we wish to draw samples from the posterior \\(p(\\mu|\\{y_i\\}_{i=1}^n)\\). (Okay, we know the posterior in closed form, \\(\\mu|\\{y_i\\}_{i=1}^n \\sim N(\\bar y,n^{-1}),\\; \\bar y = n^{-1}\\sum_{i=1}^n y_i\\), but for the sake of illustration…) A model file for this simple model, where we are for some reason also interested in the quantity \\(\\mu^2\\) may be something like the following: INCLUDE_BLOCK{ // not used here } DATA_BLOCK{ DATA_VECTOR(y); // data to be passed from R } SETUP_BLOCK{ // not used here } VARIABLES_BLOCK{ PARAMETER_SCALAR(mu); // the parameter GENERATED_SCALAR(mu_squared); // a transformation of the parameter } MODEL_BLOCK{ // log-likelihood function target += stan::math::normal_lpdf(y,mu,1); // note stan math library available // generated quantities mu_squared = mu*mu; } From now on, we assume the above code is available in a file titled iidmodel.cpp in the current working directory. 2.1 Building a model The first step for performing analysis is to “build” the model. This process involves two step: Translating the model file into a working c++ program (the code in the “blocks” should in all cases be valid c++ code) Compiling the program to obtain a stand alone binary that communicates with R using text files. Unless your model file contains error, this process should be completely hidden for the user. Building of the model is done using the function build(), e.g. model&lt;-pdphmc::build(&quot;iidmodel.cpp&quot;) This process should result in a folder “iidmodel_files” containing a single standalone program. The S4 object model contains different metadata regarding the model and the path to the program generated. If the model is not correctly specified, pdphmc::build() outputs the compiler errors generated, which may be used to diagonse the problem. See the documentation for further arguments to pdphmc::build(), in particular the event rate specification and the mass matrix are specified at this stage. 2.2 Running a model The next step is to run the model using the function pdphmc::run() for a given data set. Here we simulate a data set with \\(n=50\\), and pass it to pdphmc::run() in a named list (name correspond to name given in the DATA_VECTOR()-macro in the model file above). set.seed(123) data &lt;- rnorm(50,mean=3.0) # the data set to be considered fit &lt;- run(model,data=list(y=data)) # output is stored in S4 object &quot;fit&quot; 2.3 Handling output Finally the output from pdphmc::run() may be used in different ways. Most importantly get summary statistics (based on rstan::monitor()): pdphmc::getMonitor(fit) #compare mean of mu against: mean(data) #compare sd of mu against: sqrt(1.0/50.0) get trace plots to check convergence (trace plot also include warmup period) pdphmc::trace.plot(fit,c(&quot;mu&quot;,&quot;mu_squared&quot;)) pdphmc actually both records two types of samples from the underlying PDMP; discrete samples (which were displayed above, and may be used as regular MCMC samples) and continuous/integrated samples. The continuous samples only have the correct first order moments and should not be used for estimating standard deviations, quantiles etc. Continuous samples are only recorded for the GENERATED-quantities. The continuous samples may be extracted using e.g. pdphmc::getIntMonitor(fit) pdphmc::trace.plot.int(fit) "],["the-model-file.html", "3 The model file 3.1 The blocks", " 3 The model file Below is 3.1 The blocks foo "]]
